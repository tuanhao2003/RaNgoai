##### (done) 1 : Lộc - Quản lý lương nhân viên #####
Tôi là một sinh viên năm ba ngành công nghệ thông tin ở đại học Sài Gòn. Tôi đang làm một số bài tập giải thuật của thầy giao cho và sử dụng ngôn ngữ Java, cụ thể tôi đang phát triển một hàm nhằm tính lương cho nhân viên dựa vào số buổi đi làm.
Hệ thống nhận vào một danh sách nhân viên, mỗi nhân viên có thông tin về số buổi đi làm và mức lương mỗi buổi. Kết quả trả về là tổng lương của từng nhân viên.
Mặc dù đoạn mã đã hoạt động, nhưng vẫn còn một số vấn đề như sau:
Mã nguồn chưa được tối ưu hóa, cần tách các logic tính toán lương thành các phương thức riêng biệt để dễ bảo trì và mở rộng.
Hiện tại, hệ thống tính lương của tôi đang tính trực tiếp trong vòng lặp, không tuân theo nguyên tắc Single Responsibility Principle.
Cần đảm bảo rằng nếu số buổi làm việc hoặc mức lương nhập vào không hợp lệ thì hệ thống có thể xử lý ngoại lệ một cách hợp lý.
Đoạn mã cần phải đáp ứng một số ràng buộc nhất định như sau:
Nếu số buổi làm việc nhỏ hơn 0, hệ thống sẽ phải trả về lỗi, nếu mức lương mỗi buổi của nhân viên nhỏ hơn 0, hệ thống cũng sẽ phải báo lỗi. Kết quả trả về phải chính xác và có định dạng rõ ràng.
Hãy giúp tôi tái cấu trúc lại đoạn mã bên dưới để giải quyết các vấn đề được nêu bên trên, các thay đổi và chỉnh sửa cần phải được tóm tắt ở cuối.
Dưới này là đoạn mã của tôi, bạn sửa lại theo đúng những gì tôi yêu cầu:
```java
import java.util.ArrayList;
import java.util.List;

class EmployeeInfomation {
    String name;
    int days;
    double salary;

    public EmployeeInfomation(String name, int days, double salary) {
        this.name = name;
        this.days = days;
        this.salary = salary;
    }
}

class SalaryCalculator {
    public static void main(String[] args) {
        List<EmployeeInfomation> employees = new ArrayList<>();
        employees.add(new EmployeeInfomation("John", 20, 50));
        employees.add(new EmployeeInfomation("Jane", 15, 60));
        employees.add(new EmployeeInfomation("Doe", 22, 45));

        for (EmployeeInfomation emp : employees) {
            double totalSalary = emp.days * emp.salary;
            System.out.println("EmployeeInfomation: " + emp.name + ", Salary: $" + totalSalary);
        }
    }
}
```



##### (done) 2 : Hào - Tối đa lợi nhuận cắt thanh sắt #####
Tôi là một lập trình viên làm việc tự do. Tôi đang nhận một dự án phát triển một hệ thống quản lý nguyên vật liệu cho một công xưởng, được viết bằng ngôn ngữ Java. Tôi đã làm một tính năng giúp tính toán việc phân đoạn các thanh sắt sao cho tối đa lợi nhuận.
Đoạn mã của tôi nhận vào một danh sách chứa các giá trị bán ra của thanh sắt dựa trên độ dài (độ dài là chỉ mục của giá trị đó trong danh sách), và một số nguyên đại diện cho độ dài của thanh sắt cần cắt. Kết quả trả về là lợi nhuận lớn nhất có thể thu được từ việc cắt thanh sắt đó.
Tuy đoạn mã đã hoạt động đúng như ý tôi muốn nhưng vì đoạn mã đang sử dụng đệ quy để thực hiện tìm lợi nhuận lớn nhất, điều này làm cho đoạn mã hoạt động khá chậm khi mảng có độ dài lớn. Tôi cần tái cấu trúc lại đoạn mã để tối ưu thời gian chạy.
Hệ thống cần đáp ứng các yêu cầu sau để hoạt động ổn định: độ dài của thanh sắt được cho phải lớn hơn 0, các giá trị trong danh sách cũng phải lớn hơn 0 và được tính bằng đơn vị tiền tệ Việt Nam đồng. 
Hãy tái cấu trúc lại đoạn mã dưới đây cho phù hợp với yêu cầu và mô tả bên trên. Việc tái cấu trúc nên được làm cẩn thận vì đây là một trong số các chức năng chính trong hệ thống của tôi. Hãy tổng hợp các thay đổi và chỉnh sửa ở cuối.
Đây là đoạn mã mà tôi đã viết:
```java
import java.util.*;
public class IronBarMaximumProfit {
    public static int maxProfitCutting(int[] price, int n) {
        int maxProfit = Integer.MIN_VALUE;
        if (n == 0) return 0;
        for (int i = 1; i <= n; i++) {
            maxProfit = Math.max(maxProfit, price[i - 1] + maxProfitCutting(price, n - i));
        }
        return maxProfit;
    }

    public static void main(String[] args) {
        int[] price = {10000, 50000, 80000, 90000, 100000, 170000, 200000};
        int bar = 8; 
        System.out.println(maxProfitCutting(price, bar));
    }
}
```



##### 3 : Lộc - Sắp xếp túi đồ trong game #####
Tôi là một lập trình viên phần mềm. Nhóm của tôi đang làm việc trên một hệ thống xử lý dữ liệu túi đồ của trò chơi, trong đó có một bài toán cần sắp xếp vật phẩm trong túi đồ của tài khoản đó theo thứ tự tăng dần hoặc giảm dần. Tôi đang phát triển ứng dụng đó bằng Java.
Túi đồ chứa 3 loại vật phẩm: vật phẩm hồi máu, vũ khí, công cụ giải đố, nhưng quan trọng nhất là vật phẩm hồi máu trong một tựa game sinh tồn.
Vì thế tôi đã tạo ra một đoạn code để sắp xếp thứ tự vật phẩm sở hữu của loại vật phẩm đó, lần lượt là vật phẩm hồi máu, vũ khí, công cụ giải đố.
Đoạn mã đã hoạt động nhưng vẫn còn vấn đề sau:
Sắp xếp còn khá chậm, tôi cần bạn tối ưu về thời gian và không gian để đoạn mã thực hiện nhanh hơn.
Đoạn mã cần phải đáp ứng một số ràng buộc nhất định như sau:
Số lượng vật phẩm hiển thị phải lớn hơn hoặc bằng 0, vật phẩm hồi máu sẽ là loại đầu tiên xuất hiện, tiếp theo là vũ khí, cuối cùng là vật phẩm giải đố.
Dưới này là đoạn mã của tôi, bạn tối ưu lại nhưng mà không làm thay đổi chức năng của đoạn code: 
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Item {
    String name;
    String type;
    int quantity;

    public Item(String name, String type, int quantity) {
        this.name = name;
        this.type = type;
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return name + " (" + type + ") - " + quantity;
    }
}

public class InventorySorter {
    public static void main(String[] args) {
        List<Item> inventory = new ArrayList<>();
        inventory.add(new Item("Potion", "Healing", 5));
        inventory.add(new Item("Herb", "Healing", 3));
        inventory.add(new Item("Gun", "Weapon", 1));
        inventory.add(new Item("Key", "Puzzle", 4));
        inventory.add(new Item("Map", "Puzzle", 6));
        inventory.add(new Item("Sword", "Weapon", 2));

    Collections.sort(inventory, new Comparator<Item>() {
        @Override
        public int compare(Item o1, Item o2) {
            int priority1 = getTypePriority(o1.type);
            int priority2 = getTypePriority(o2.type);
    
            if (priority1 != priority2) {
                return Integer.compare(priority1, priority2);
            }
    
            return Integer.compare(o2.quantity, o1.quantity);
        }
    
        private int getTypePriority(String type) {
            switch (type) {
                case "Healing": return 0;
                case "Weapon": return 1;
                case "Puzzle": return 2;
                default: return 3;
            }
        }
    });

        for (Item item : inventory) {
            System.out.println(item);
        }
    }
}
```




##### (Done) 4 : Khải - Chi phí vận chuyển rẻ nhất #####
Tôi một học sinh trung học. Tôi muốn tập làm quen với lập trình. Tôi đang làm một chương trình tính giá tiền vận chuyển hàng của các nhà cung cấp khác nhau bằng ngôn ngữ Java. Chương trình sẽ nhận vào 1 mảng danh sách các nhà vận chuyển bao gồm đơn giá trên khoảng cách và đơn giá trên khối lượng, và thông tin của đơn hàng gồm khoảng cách và khối lượng. Tiến hành tính toán để có được giá tiền vận chuyển. Để tính ra được kết quả hợp lệ dữ liệu khoảng cách phải lớn hơn 0, khối lượng phải lớn hơn 0. Tôi đã có đoạn mã đã hoạt động những trong đó vẫn còn một số vấn đề: Tôi đang sử dụng mảng tĩnh, thực hiện tính toán tiền trực tiếp trong vòng lặp thay vì trong lớp đối tượng, thiếu format đơn vị VND. Tôi muốn tái cấu trúc mã này và sửa những vấn đề kể trên, việc tái cấu trúc này nên được làm cẩn thận vì tính toán sai lầm có thể dẫn đến tổn thất lớn. Hãy tái cấu trúc mã lại và tổng hợp thay đổi ở cuối cùng. Dưới đây là đoạn mã tôi đã viết.
```java
import java.util.ArrayList;
import java.util.List;

class TransportProvider {
    String name;
    double pricePerDistance; 
    double pricePerWeight;
    public TransportProvider(String name, double pricePerDistance, double pricePerWeight) {
        this.name = name;
        this.pricePerDistance = pricePerDistance;
        this.pricePerWeight = pricePerWeight;
    }
}

public class TransportCostOptimizer {
    public static void main(String[] args) {
        TransportProvider providers [] = new TransportProvider [3];
        providers[0] = (new TransportProvider("Provider A",5000, 10000));
        providers[1]= (new TransportProvider("Provider B", 6000, 9000));
        providers[2]=(new TransportProvider("Provider C", 3000, 12000));
        double distance = 100; 
        double weight = 50;    
        TransportProvider cheapestProvider = null;
        double minCost = Double.MAX_VALUE;
        for (int i = 0; i<providers.length; i++) {
            double cost = (providers[i].pricePerDistance * distance) + (providers[i].pricePerWeight * weight);
            System.out.println("Chi phí của " + providers[i].name + " là: " + cost + " VND");
            if (cost < minCost) {
                minCost = cost;
                cheapestProvider = providers[i];
            }
        }
        if (cheapestProvider != null) {
            System.out.println("\nNhà vận chuyển rẻ nhất: " + cheapestProvider.name + " với chi phí " + minCost + "VND");
        }
    }
}
```
###fix
Tôi là một học sinh trung học đang tự học lập trình. Tôi đang làm một chương trình tính giá tiền vận chuyển hàng của các nhà cung cấp khác nhau bằng ngôn ngữ Java. Chương trình nhận vào một mảng chứa nhiều đơn hàng, mỗi đơn hàng đều có thuộc tính tên người vận chuyển, khoảng cách giao hàng và khối lượng hàng hóa. Kết quả trả về là giá tiền vận chuyển.
Để tính ra được kết quả hợp lệ, chương trình yêu cầu dữ liệu khoảng cách phải lớn hơn `0`, khối lượng phải lớn hơn `0`.
Tuy đoạn mã đã hoạt động đúng với mục đích mà tôi mong muốn nhưng vẫn còn một số vấn đề sau làm cho đoạn mã khó mở rộng và kết quả chưa được rõ ràng: đoạn mã đang dùng mảng tĩnh và thực hiện tính toán chi phí trực tiếp trong vòng lặp thay, điều này gây ra việc thiếu khả năng mở rộng và tái sử dụng đoạn mã cho các chương trình tiếp theo; thiếu định dạng cho đơn vị tiền tệ (được tính theo đơn vị Việt Nam đồng) điều này làm cho kết quả trả về rất khó nhìn và không rõ ràng.
Hãy thực hiện tái cấu trúc lại đoạn mã để sửa các vấn đề trên, việc tái cấu trúc nên được làm cẩn thận, không được thay đổi cách thức hoạt động của đoạn mã. Tổng hợp những thay đổi ở cuối và so sánh so với đoạn mã cũ.
Sau đây là đoạn mã mà tôi đã viết:
```java
import java.util.ArrayList;
import java.util.List;

class TransportProvider {
    String name;
    double pricePerDistance; 
    double pricePerWeight;
    public TransportProvider(String name, double pricePerDistance, double pricePerWeight) {
        this.name = name;
        this.pricePerDistance = pricePerDistance;
        this.pricePerWeight = pricePerWeight;
    }
}

public class TransportCostOptimizer {
    public static void main(String[] args) {
        TransportProvider providers [] = new TransportProvider [3];
        providers[0] = (new TransportProvider("Provider A",5000, 10000));
        providers[1]= (new TransportProvider("Provider B", 6000, 9000));
        providers[2]=(new TransportProvider("Provider C", 3000, 12000));
        double distance = 100; 
        double weight = 50;    
        TransportProvider cheapestProvider = null;
        double minCost = Double.MAX_VALUE;
        for (int i = 0; i<providers.length; i++) {
            double cost = (providers[i].pricePerDistance * distance) + (providers[i].pricePerWeight * weight);
            System.out.println("Chi phí của " + providers[i].name + " là: " + cost + " VND");
            if (cost < minCost) {
                minCost = cost;
                cheapestProvider = providers[i];
            }
        }
        if (cheapestProvider != null) {
            System.out.println("\nNhà vận chuyển rẻ nhất: " + cheapestProvider.name + " với chi phí " + minCost + "VND");
        }
    }
}
```
###



##### 5 : Khang - Tính toán sản phẩm có lợi nhuận cao nhất #####
Tôi là một lập trình viên làm việc tự do. Một công ty đang phát triển một hệ thống quản lý kho hàng để tối ưu hóa việc theo dõi và phân phối sản phẩm. Tôi đang phát triển một ứng dụng được viết bằng ngôn ngữ Java nhằm giải quyết bài toán tính toán lợi nhuận sản phẩm trong bối cảnh quản lý kho hàng.
Để đảm bảo tính chính xác và độ tin cậy của hệ thống, tôi cần kiểm tra kết quả đầu ra của chương trình dựa trên các tiêu chí cụ thể. Trong quá trình phát triển hệ thống, tôi cần đảm bảo rằng kết quả đầu ra luôn chính xác và không có lỗi khi nhập dữ liệu.
Hệ thống nhận vào danh sách sản phẩm với các thông tin:- Tên sản phẩm (chuỗi ký tự).- Số lượng sản phẩm (số nguyên, phải lớn hơn 0).- Giá vốn (số thực, phải lớn hơn 0).- Giá bán (số thực, phải lớn hơn 0).- Khi người dùng bỏ trống tên sản phẩm, quá trình nhập sẽ dừng lại và hệ thống sẽ bắt đầu tính toán lợi nhuận.
Kết quả trả về là tên của sản phẩm có lợi nhuận cao nhất.
Tuy nhiên, ứng dụng của tôi vẫn còn một số hạn chế như: Khi nhập sai dữ liệu (ví dụ: số lượng hoặc giá không hợp lệ), chương trình không cho phép nhập lại mà chỉ hiển thị lỗi. Nếu người dùng nhập trống hoặc nhập 0 ở phần số lượng, giá vốn hoặc giá bán, chương trình không xử lý linh hoạt. Chưa có cách để nhập lại dữ liệu nếu lỡ nhập sai mà không cần khởi động lại chương trình.
Hãy giúp tôi tái cấu trúc lại đoạn mã bên dưới để giải quyết các vấn đề được nêu bên trên, các thay đổi và chỉnh sửa không được chú thích trong mã mà cần phải được tóm tắt ở cuối.
Dưới đây là đoạn mã tôi đã viết:
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Product {
    private String name;
    private int soluong;
    private double von;
    private double ban;

    public Product(String name, int soluong, double von, double ban) {
        if (soluong <= 0 || von <= 0 || ban <= 0) {
            throw new IllegalArgumentException("Số lượng, giá vốn và giá bán phải lớn hơn 0.");
        }
        this.name = name;
        this.soluong = soluong;
        this.von = von;
        this.ban = ban;
    }

    public double getProfit() {
        return (ban - von) * soluong;
    }

    public String getName() {
        return name;
    }
}

public class InventoryCalculator {
    public static Product getMaxProfitProduct(List<Product> products) {
        if (products == null || products.isEmpty()) {
            throw new IllegalArgumentException("Danh sách sản phẩm không được trống.");
        }
        return products.stream()
                .max((p1, p2) -> Double.compare(p1.getProfit(), p2.getProfit()))
                .orElseThrow();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<Product> products = new ArrayList<>();

        while (true) {
            System.out.print("Nhập tên sản phẩm (bỏ trống để kết thúc): ");
            String name = scanner.nextLine().trim();
            if (name.isEmpty()) {
                break;
            }

            try {
                System.out.print("Nhập số lượng: ");
                int soluong = Integer.parseInt(scanner.nextLine().trim());

                System.out.print("Nhập giá vốn: ");
                double von = Double.parseDouble(scanner.nextLine().trim());

                System.out.print("Nhập giá bán: ");
                double ban = Double.parseDouble(scanner.nextLine().trim());

                products.add(new Product(name, soluong, von, ban));
            } catch (NumberFormatException e) {
                System.out.println("Vui lòng nhập số hợp lệ cho số lượng, giá vốn và giá bán.");
            } catch (IllegalArgumentException e) {
                System.out.println(e.getMessage());
            }
        }

        scanner.close();

        if (!products.isEmpty()) {
            Product maxProfitProduct = getMaxProfitProduct(products);
            System.out.println("Sản phẩm có lợi nhuận cao nhất: " + maxProfitProduct.getName());
        } else {
            System.out.println("Không có sản phẩm nào để tính toán.");
        }
    }
}
```



##### 6 : Lộc - tối ưu nguồn tiền build pc #####
Tôi là một lập trình viên làm việc tự do.
Tôi đang phát triển một ứng dụng được viết bằng ngôn ngữ Java nhằm giải quyết bài toán tính toán điểm hiệu năng trên giá thành được viết bằng ngôn ngữ Java. Để đảm bảo tính chính xác và độ tin cậy của hệ thống, tôi cần kiểm tra kết quả đầu ra của chương trình dựa trên các tiêu chí cụ thể.
Hệ thống nhận vào một mảng danh sách gồm lần lượt tên linh kiện, giá, điểm hiệu năng. Linh kiện gồm 4 loại là cpu, main, ram, card màn hình. Kết quả trả về sau khi xử lý là một danh sách các linh kiện có tên, giá, điểm hiệu năng và điểm hiệu năng trên giá thành tốt nhất.
Tuy đã hoạt động đúng mục đích nhưng ứng dụng vẫn cần một số cải tiến để giải quyết: Phải tạo riêng một hàm nhập các sản phẩm vào chứ không được gán cứng trong đoạn mã, giá linh kiện không được nhỏ hơn 0.
Hệ thống cần đáp ứng các yêu cầu sau để hoạt động chính xác: Để xây dựng được một bộ máy tính cần đầy đủ 4 loại linh kiện, nếu không kết quả phải trả về là "không đủ linh kiện để hoàn thành máy tính"
Tôi muốn tái cấu trúc lại đoạn mã để sửa các trường hợp trên. Việc tái cấu trúc để sửa các trường hợp trên là rất quan trọng vì nếu không cho nhập các linh kiện vào thì hệ thống sẽ bị hạn chế, không thể phát triển và mở rộng thêm các chức năng khác.
Hãy giúp tôi tái cấu trúc lại đoạn mã để giải quyết các vấn đề trên, các thay đổi và chỉnh sửa cần phải được tóm tắt ở cuối.
```java
import java.util.Arrays;

public class MaxDamageCombo {
    public static int[] maxDamageComboList(int[] damageRecorded, int k) {
        if (damageRecorded.length < k) {
            return new int[0];
        }

        int currentTotalDamage = 0;
        for (int i = 0; i < k; i++) {
            currentTotalDamage += damageRecorded[i];
        }

        int maxSum = currentTotalDamage;
        int startComboSkill = 0;

        for (int i = k; i < damageRecorded.length; i++) {
            currentTotalDamage += damageRecorded[i] - damageRecorded[i - k];

            if (currentTotalDamage > maxSum) {
                maxSum = currentTotalDamage;
                startComboSkill = i - k + 1;
            }
        }

        return Arrays.copyOfRange(damageRecorded, startComboSkill, startComboSkill + k);
    }

    public static void main(String[] args) {

    }
}import java.util.*;

class Component {
    String name, type;
    double price, performance, ppRatio;

    public Component(String name, String type, double price, double performance) {
        this.name = name;
        this.type = type;
        this.price = price;
        this.performance = performance;
        this.ppRatio = performance / price;
    }

    @Override
    public String toString() {
        return type + ": " + name + " | Giá: " + price + " | Điểm: " + performance + " | P/P: " + ppRatio;
    }
}

class PCBuilder {
    private static final List<String> REQUIRED_TYPES = Arrays.asList("CPU", "RAM", "Mainboard", "Card màn hình");
    
    public static Map<String, Component> getBestComponents(Component[] components) {
        Map<String, Component> bestPC = new LinkedHashMap<>();
        
        for (Component c : components) {
            bestPC.putIfAbsent(c.type, c);
            if (c.ppRatio > bestPC.get(c.type).ppRatio) {
                bestPC.put(c.type, c);
            }
        }
        
        return bestPC;
    }
    
    public static boolean isValidPC(Map<String, Component> bestPC) {
        return bestPC.keySet().containsAll(REQUIRED_TYPES);
    }
    
    public static void printBestPC(Map<String, Component> bestPC) {
        if (!isValidPC(bestPC)) {
            System.out.println("Không đủ linh kiện để lắp một bộ PC hoàn chỉnh!");
            return;
        }
        for (String type : REQUIRED_TYPES) {
            System.out.println(bestPC.get(type));
        }
    }
}

class BestPCBuilder {
    public static void main(String[] args) {

    }
}
```



##### 7: Khoa - Hệ thống kiểm tra số lượng vé còn hay không để xác nhận đặt vé thành công #####
Tôi là một nhà phát triển phần mềm đang làm việc tại một công ty chuyên về hệ thống đặt vé xem phim trực tuyến, tôi đang cùng nhóm triển khai dự án quản lý vé nhằm tối ưu hóa quy trình và ngăn chặn tình trạng bán vé vượt mức. Trong quá trình phát triển ứng dụng đặt vé bằng Java, chúng tôi nhận thấy cần thiết phải có một hệ thống kiểm tra số lượng vé khả dụng trước khi xác nhận đặt vé để đảm bảo tính chính xác và công bằng.
Hệ thống sẽ nhận đầu vào gồm ID phim, suất chiếu và số lượng vé yêu cầu. Sau đó, nó sẽ kiểm tra kho vé để xác định xem số lượng vé còn lại có đủ đáp ứng yêu cầu hay không. Nếu đủ vé, quy trình đặt vé sẽ tiếp tục; ngược lại, hệ thống sẽ thông báo số lượng vé còn lại và yêu cầu người dùng điều chỉnh.
Điều quan trọng là hệ thống phải đảm bảo xử lý nhanh chóng, chính xác và ngăn ngừa các lỗi đặt vé trùng lặp hoặc vượt quá số lượng. Việc triển khai tính năng này là rất quan trọng để nâng cao trải nghiệm người dùng, giảm thiểu sai sót và đảm bảo quá trình đặt vé diễn ra suôn sẻ.
Sau đây là đoạn mã mà tôi đã viết:
```java
import java.util.HashMap;
import java.util.Map;

public class TicketBookingSystem {
    private Map<String, Integer> availableTickets;

    public TicketBookingSystem() {
        // Giả lập số lượng vé có sẵn cho từng suất chiếu
        availableTickets = new HashMap<>();
        availableTickets.put("MOVIE_001_18:00", 10);
        availableTickets.put("MOVIE_002_20:00", 5);
    }

    public boolean checkAvailability(String movieId, String showTime, int requestedTickets) {
        String key = movieId + "_" + showTime;
        int remainingTickets = availableTickets.getOrDefault(key, 0);
        
        if (requestedTickets <= remainingTickets) {
            return true; // Còn đủ vé
        } else {
            return false; // Không đủ vé
        }
    }

    public static void main(String[] args) {
        TicketBookingSystem system = new TicketBookingSystem();
        
        String movieId = "MOVIE_001";
        String showTime = "18:00";
        int requestedTickets = 4;
        
        if (system.checkAvailability(movieId, showTime, requestedTickets)) {
            System.out.println("Vé còn đủ. Tiếp tục đặt vé!");
        } else {
            System.out.println("Vé không đủ. Vui lòng chọn số lượng ít hơn hoặc suất chiếu khác!");
        }
    }
}
```



##### 8 : Khoa - Hệ thống phân loại thư điện tử tự động  ######
Tôi là một nhà phát triển phần mềm, và nhóm của tôi đang làm việc trên một hệ thống hỗ trợ quản lý thư điện tử thông minh, nhằm tự động phân loại thư điện tử dựa trên nội dung. Trong quá trình phát triển, tôi nhận thấy việc phân loại thủ công mất nhiều thời gian và dễ nhầm lẫn, nên cần một hệ thống phân loại thư điện tử dựa trên từ khóa có sẵn.
Ứng dụng được viết bằng Java, nhận vào một chuỗi nội dung thư điện tử và trả về danh mục phù hợp như "Thư quảng cáo", "Hóa đơn thanh toán", "Lịch họp", v.v. Hệ thống cần so sánh nội dung với danh sách từ khóa cố định, đảm bảo phân loại chính xác.
Hãy tạo mã nguồn Java cho hệ thống này, với chú thích đầy đủ để dễ hiểu và bảo trì.
Sau đây là đoạn mã mà tôi đã viết:
```java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

class EmailClassifier {
    private Map<String, String> categories;

    // Khởi tạo danh mục thư với từ khóa hardcode
    public EmailClassifier() {
        categories = new HashMap<>();
        categories.put("khuyến mãi", "Thư quảng cáo");
        categories.put("giảm giá", "Thư quảng cáo");
        categories.put("hóa đơn", "Hóa đơn thanh toán");
        categories.put("nợ", "Hóa đơn thanh toán");
        categories.put("họp", "Lịch họp");
        categories.put("tuyển dụng", "Cơ hội việc làm");
        categories.put("phỏng vấn", "Cơ hội việc làm");
        categories.put("bảo mật", "Cảnh báo bảo mật");
    }

    // Phương thức phân loại thư
    public String classifyEmail(String emailContent) {
        for (Map.Entry<String, String> entry : categories.entrySet()) {
            if (emailContent.toLowerCase().contains(entry.getKey())) {
                return entry.getValue();
            }
        }
        return "Khác"; // Nếu không tìm thấy danh mục phù hợp
    }
}

public class EmailFilterApp {
    public static void main(String[] args) {
        EmailClassifier classifier = new EmailClassifier();
        Scanner scanner = new Scanner(System.in);

        System.out.println("Nhập nội dung thư để phân loại:");
        String emailContent = scanner.nextLine();

        String category = classifier.classifyEmail(emailContent);
        System.out.println("Loại thư: " + category);

        scanner.close();
    }
}
```



##### 9 : Khải - Loại bỏ kí tự dấu trong chuỗi tiếng Việt #####
Tôi là một gia sư dạy lập trình. Tôi đang viết một chương trình sử dụng ngôn ngữ Java dùng để loại bỏ những kí tự có dấu trong tiếng Việt, đây là bài lập trình mẫu cho những học sinh của tôi.
Chương trình này sẽ nhận vào một chuỗi các kí tự tiếng Việt, việc của nó sẽ là phát hiện những kí tự có dấu như 'á', 'ề', 'ợ',... thay thế chúng bằng kí tự không có dấu 'a', 'e', 'o'. Ví dụ truyền vào chuỗi "Chào bạn 123!", kết quả sẽ là "Chao ban 123!".
Tuy chương trình đã chạy đúng những gì tôi mong đợi, nhưng cách triển khai quá dài dòng dẫn đến hiệu suất không được tối ưu, vẫn còn đòi hỏi khai báo mảng kí tự tiếng Việt trước khá không thực tế.
Một số ràng buộc cần phải tuân theo khi tái cấu trúc: chuỗi nhập vào không được là chuỗi rỗng, những kí tự được can thiệp phải là kí tự chữ và là kí tự có dấu trong tiếng Việt, các trường hợp khác sẽ không bị ảnh hưởng, đặc biệt các chữ cái được in hoa cũng phải giữ nguyên trạng thái in hoa của chúng.
Tôi cần tái cấu trúc lại đoạn mã để xử lý các vấn đề còn tồn đọng và vẫn giữ đúng các ràng buộc, đảm bảo đầu vào và đầu ra. Việc tái cấu trúc để sửa các trường hợp trên là rất quan trọng vì chương trình này sẽ làm mẫu cho các học sinh của tôi lấy làm nền tảng cho việc học tập.
Hãy giúp tôi tái cấu trúc lại đoạn mã để giải quyết các vấn đề như hướng dẫn đã nêu trên, các thay đổi và chỉnh sửa cần phải được chú thích rõ ràng ở cuối.
Đây là đoạn mã tôi đã thực hiện.
```java
public class RemoveVietnameseLetters {
    
    public static String removeDiacritics(String text) {
        String[][] vietnameseChars = {
            {"à", "á", "ả", "ã", "ạ", "ă", "ằ", "ắ", "ẳ", "ẵ", "ặ", "â", "ầ", "ấ", "ẩ", "ẫ", "ậ"},{"è", "é", "ẻ", "ẽ", "ẹ", "ê", "ề", "ế", "ể", "ễ", "ệ"},{"ì", "í", "ỉ", "ĩ", "ị"},
            {"ò", "ó", "ỏ", "õ", "ọ", "ô", "ồ", "ố", "ổ", "ỗ", "ộ", "ơ", "ờ", "ớ", "ở", "ỡ", "ợ"},{"ù", "ú", "ủ", "ũ", "ụ", "ư", "ừ", "ứ", "ử", "ữ", "ự"},{"ỳ", "ý", "ỷ", "ỹ", "ỵ"},{"đ"}
        };
        
        String[] replacementChars = {"a", "e", "i", "o", "u", "y", "d"};
        
        for (int i = 0; i < vietnameseChars.length; i++) {
            for (String character : vietnameseChars[i]) {
                text = text.replace(character, replacementChars[i]);
                text = text.replace(character.toUpperCase(), replacementChars[i].toUpperCase());
            }
        }
        return text;
    }
    
    public static void main(String[] args) {
        String input = "Chào bạn!";
        String output = removeDiacritics(input);
        System.out.println("Văn bản gốc: " + input);
        System.out.println("Văn bản không dấu: " + output);
    }
}
```



##### 10 : Lộc - Sắp xếp điểm số và xét học bổng #####
Tôi là một lập trình viên đang làm việc cho ngành giáo dục. Tôi đang phát triển một ứng dụng được viết bằng ngôn ngữ Java nhằm giải quyết bài toán sắp xếp điểm theo thứ tự và xét học bổng trong bối cảnh trường có quá nhiều sinh viên, tính toán thủ công quá lâu. Để đảm bảo tính chính xác và độ tin cậy của hệ thống, tôi cần kiểm tra kết quả đầu ra của chương trình dựa trên các tiêu chí cụ thể.
Hệ thống nhận vào mảng danh sách các sinh viên gồm 2 thuộc tính là tên và điểm. Kết quả trả về là tên và điểm, điểm GPA theo thứ tự từ trên xuống dưới của 10 người điểm cao nhất.
Tuy nhiên ứng dụng của tôi vẫn còn một số hạn chế đó là chưa cho nhập tay danh sách các sinh viên và điểm của sinh viên đó.
Một số ràng buộc cần đảm bảo: Điểm số sẽ không được nhỏ hơn 0, nếu sinh viên ở hạng 10 có kết quả giống nhau thì sẽ bao gồm tất cả sinh viên ở mức điểm đó.
Tôi muốn tái cấu trúc lại đoạn mã để sửa các trường hợp trên. Việc tái cấu trúc để sửa các trường hợp trên là rất quan trọng vì nếu không thể tự do nhập vào danh sách các sinh viên thì lúc này hệ thống sẽ không thể mở rộng, phát triển thêm mà bị giới hạn chỉ các sinh viên có sẵn trong đoạn mã.
Hãy giúp tôi tái cấu trúc lại đoạn mã để giải quyết các vấn đề trên, các thay đổi và chỉnh sửa cần phải được tóm tắt ở cuối.
```java
import java.util.*;

class Student {
    String name;
    double gpa;

    public Student(String name, double gpa) {
        if (gpa < 0) {
            throw new IllegalArgumentException("GPA không thể nhỏ hơn 0");
        }
        this.name = name;
        this.gpa = gpa;
    }

    public String getName() {
        return name;
    }

    public double getGpa() {
        return gpa;
    }
}

public class ScholarshipEvaluator {
    public static List<Student> getTopStudents(List<Student> students) {
        students.sort((s1, s2) -> Double.compare(s2.getGpa(), s1.getGpa()));
        
        List<Student> topStudents = new ArrayList<>();
        double lastGpa = -1;
        int count = 0;

        for (Student student : students) {
            if (count < 10 || student.getGpa() == lastGpa) {
                topStudents.add(student);
                lastGpa = student.getGpa();
                count++;
            } else {
                break;
            }
        }

        return topStudents;
    }

    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", 3.9),
            new Student("Bob", 3.5),
            new Student("Charlie", 3.7),
            new Student("David", 3.8),
            new Student("Emma", 3.6),
            new Student("Frank", 4.0),
            new Student("Grace", 3.95),
            new Student("Hannah", 3.85),
            new Student("Isaac", 3.2),
            new Student("Jack", 3.3),
            new Student("Kate", 3.75),
            new Student("Liam", 3.4),
            new Student("Mason", 3.5),
            new Student("Maso", 3.5)
        );

        List<Student> topStudents = getTopStudents(students);
        System.out.println("Top sinh viên có điểm cao nhất:");
        for (Student s : topStudents) {
            System.out.println(s.getName() + " - " + s.getGpa());
        }
    }
}
```



##### 11 : Lộc - Sắp xếp công việc theo thứ tự ưu tiên #####
Tôi là một nhà phát triển phần mềm đang làm việc trong một doanh nghiệp tài chính.
Tôi đang phát triển một ứng dụng được viết bằng ngôn ngữ Java nhằm giải quyết bài toán sắp xếp danh sách công việc theo độ ưu tiên trong bối cảnh người dùng muốn tối ưu hóa tiến độ làm việc. Để đảm bảo tính chính xác và độ tin cậy của hệ thống, tôi cần kiểm tra kết quả đầu ra của chương trình dựa trên các tiêu chí cụ thể.
Đầu vào của hệ thống là một mảng các chuỗi công việc. Sau khi nhập đầu vào hệ thống sẽ sắp xếp các công việc theo thứ tự ưu tiên được chỉ định trong mỗi chuỗi. Kết quả được trả về sau khi xử lý là một mảng các chuỗi công việc đã được sắp xếp.
Tuy đã hoạt động đúng mục đích nhưng ứng dụng vẫn cần một số cải tiến để giải quyết vấn đề về khả năng mở rộng và bảo trì. Hiện tại, logic sắp xếp và in kết quả đang nằm chung trong một hàm, điều này làm cho code trở nên khó đọc và khó thay đổi.
Một số ràng buộc cần đảm bảo khi tái cấu trúc: định dạng chuỗi đầu vào phải hợp lệ (chứa dấu ngoặc đơn và số ưu tiên), hệ thống phải xử lý được các công việc có độ ưu tiên trùng nhau, và mảng đầu vào không được thay đổi ngoài phạm vi hàm sắp xếp.
Tôi muốn tái cấu trúc lại đoạn mã để sửa các trường hợp trên. Việc tái cấu trúc để sửa các trường hợp trên là rất quan trọng vì nó giúp cải thiện tính bảo trì và khả năng mở rộng của ứng dụng, đồng thời đảm bảo tính chính xác và độ tin cậy của hệ thống.
Hãy giúp tôi tái cấu trúc lại đoạn mã để giải quyết các vấn đề trên, các thay đổi và chỉnh sửa cần phải được tóm tắt ở cuối. Hãy thực hiện tái cấu trúc lại đoạn mã bằng cách tách hàm, sử dụng nguyên tắc SOLID và giải thích các thay đổi.
```java
public class TaskPrioritySorter {

    public static void main(String[] args) {

    }

    public static void sortTasksByPriority(String[] tasks) {
        int arrayLength = tasks.length;
        for (int i = 0; i < arrayLength - 1; i++) {
            for (int j = 0; j < arrayLength - i - 1; j++) {
                int priorityJ = getPriority(tasks[j]);
                int priorityJPlus1 = getPriority(tasks[j + 1]);

                if (priorityJ > priorityJPlus1) {
                    String temp = tasks[j];
                    tasks[j] = tasks[j + 1];
                    tasks[j + 1] = temp;
                }
            }
        }
        System.out.println("Danh sách công việc theo thứ tự ưu tiên:");
        for (String task : tasks) {
            System.out.println(task);
        }
    }

    private static int getPriority(String task) {
        int openParenthesisIndex = task.lastIndexOf('(');
        int closeParenthesisIndex = task.lastIndexOf(')');
        return Integer.parseInt(task.substring(openParenthesisIndex + 1, closeParenthesisIndex));
    }
}
```



##### 12 : Khang - Sắp xếp lịch khám cho bệnh nhân theo mức độ nghiêm trọng #####
Tôi là một nhà phát triển làm việc trong một bệnh viện tư nhân.
Tôi cần xây dựng một ứng dụng Java để sắp xếp danh sách lịch khám cho bệnh nhân dựa trên mức độ nghiêm trọng, nhằm tối ưu hóa thời gian và nâng cao sự hài lòng của bệnh nhân. Để đảm bảo tính chính xác và độ tin cậy của hệ thống, tôi cần kiểm tra kết quả đầu ra của chương trình dựa trên các tiêu chí cụ thể.
Yêu cầu hệ thống: Nhận vào một mảng chuỗi lịch khám bệnh của bệnh nhân, Kết quả trả về là danh sách lịch khám đã được sắp xếp theo mức độ nghiêm trọng từ 1 đến 5 (1 là ít nghiêm trọng nhất, 5 là nghiêm trọng nhất), Định dạng chuỗi đầu vào phải hợp lệ (bao gồm thông tin bệnh nhân và mức độ nghiêm trọng), Hệ thống phải xử lý được các trường hợp bệnh nhân có mức độ nghiêm trọng trùng nhau, Đảm bảo độ chính xác cao trong quá trình sắp xếp, giúp quy trình khám bệnh diễn ra hiệu quả.
Tuy ứng dụng đã hoạt động đúng mục đích, nhưng vẫn cần một số cải tiến để nâng cao khả năng mở rộng và bảo trì. Hiện tại, logic kiểm tra tính hợp lệ của đầu vào, xử lý danh sách bệnh nhân và in kết quả đang nằm trong cùng một lớp, khiến mã nguồn trở nên khó đọc và khó bảo trì.
Một số ràng buộc cần đảm bảo khi tái cấu trúc: Định dạng chuỗi đầu vào phải hợp lệ (bao gồm tên bệnh nhân và mức độ nghiêm trọng từ 1 đến 5), Hệ thống phải xử lý các trường hợp bệnh nhân có mức độ nghiêm trọng trùng nhau, Mảng đầu vào không được thay đổi ngoài phạm vi của hàm sắp xếp.
Tôi muốn tái cấu trúc lại đoạn mã để đảm bảo các điều kiện trên. Việc tái cấu trúc này rất quan trọng nhằm cải thiện tính bảo trì, khả năng mở rộng của ứng dụng, đồng thời nâng cao độ chính xác và tin cậy của hệ thống.
Hãy giúp tôi tái cấu trúc đoạn mã bằng cách tách hàm một cách hợp lý và giải thích các thay đổi sau khi hoàn thành.

```java
import java.util.*;

// Lớp đại diện cho lịch khám bệnh của bệnh nhân
class Appointment implements Comparable<Appointment> {
    private String patientName;
    private int severityLevel;

    public Appointment(String patientName, int severityLevel) {
        this.patientName = patientName;
        this.severityLevel = severityLevel;
    }

    public String getPatientName() {
        return patientName;
    }

    public int getSeverityLevel() {
        return severityLevel;
    }

    // Phương thức so sánh để sắp xếp theo mức độ nghiêm trọng giảm dần
    @Override
    public int compareTo(Appointment other) {
        return Integer.compare(other.severityLevel, this.severityLevel);
    }

    @Override
    public String toString() {
        return "Patient: " + patientName + ", Severity Level: " + severityLevel;
    }
}

public class AppointmentScheduler {
    
    // Kiểm tra tính hợp lệ của đầu vào
    private static boolean isValidInput(String input) {
        return input.matches("^[a-zA-Z ]+: [1-5]$");
    }

    public static List<Appointment> scheduleAppointments(String[] appointments) {
        List<Appointment> appointmentList = new ArrayList<>();
        
        for (String entry : appointments) {
            if (!isValidInput(entry)) {
                System.out.println("Invalid input format: " + entry);
                continue;
            }
            
            String[] parts = entry.split(": ");
            String patientName = parts[0].trim();
            int severityLevel = Integer.parseInt(parts[1].trim());
            
            appointmentList.add(new Appointment(patientName, severityLevel));
        }
        
        // Sắp xếp danh sách theo mức độ nghiêm trọng
        Collections.sort(appointmentList);
        return appointmentList;
    }
  public static void main(String[] args) {

  }
```
